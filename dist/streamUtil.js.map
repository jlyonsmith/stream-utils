{"version":3,"sources":["../src/streamUtil.js"],"names":["stringToStream","s","Readable","read","push","streamToBuffer","readable","Promise","resolve","reject","chunks","writable","Writable","write","chunk","encoding","callback","on","Buffer","concat","error","pipe","pipeToPromise","promise","file"],"mappings":";;;;;;;;AAAA;;AAEO,MAAMA,cAAc,GAAIC,CAAD,IAC5B,IAAIC,gBAAJ,CAAa;AACXC,EAAAA,IAAI,GAAG;AACL,SAAKC,IAAL,CAAUH,CAAV,EADK,CAEL;;AACA,SAAKG,IAAL,CAAU,IAAV;AACD;;AALU,CAAb,CADK;;;;AASA,MAAMC,cAAc,GAAIC,QAAD,IAC5B,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/B,MAAIC,MAAM,GAAG,EAAb;AACA,MAAIC,QAAQ,GAAG,IAAIC,gBAAJ,CAAa;AAC1BC,IAAAA,KAAK,CAACC,KAAD,EAAQC,QAAR,EAAkBC,QAAlB,EAA4B;AAC/BN,MAAAA,MAAM,CAACN,IAAP,CAAYU,KAAZ,EAD+B,CAE/B;;AACAE,MAAAA,QAAQ;AACT;;AALyB,GAAb,CAAf;AAQAV,EAAAA,QAAQ,CAACW,EAAT,CAAY,KAAZ,EAAmB,MAAMT,OAAO,CAACU,MAAM,CAACC,MAAP,CAAcT,MAAd,CAAD,CAAhC;AACAJ,EAAAA,QAAQ,CAACW,EAAT,CAAY,OAAZ,EAAsBG,KAAD,IAAWX,MAAM,CAACW,KAAD,CAAtC;AACAd,EAAAA,QAAQ,CAACe,IAAT,CAAcV,QAAd;AACD,CAbD,CADK;;;;AAgBA,SAASW,aAAT,CAAuBhB,QAAvB,EAAiCK,QAAjC,EAA2C;AAChD,QAAMY,OAAO,GAAG,IAAIhB,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/CH,IAAAA,QAAQ,CAACW,EAAT,CAAY,OAAZ,EAAsBG,KAAD,IAAWX,MAAM,CAACW,KAAD,CAAtC;AACAT,IAAAA,QAAQ,CAACM,EAAT,CAAY,OAAZ,EAAsBG,KAAD,IAAWX,MAAM,CAACW,KAAD,CAAtC;AACAT,IAAAA,QAAQ,CAACM,EAAT,CAAY,QAAZ,EAAuBO,IAAD,IAAUhB,OAAO,CAACgB,IAAD,CAAvC;AACD,GAJe,CAAhB;AAKAlB,EAAAA,QAAQ,CAACe,IAAT,CAAcV,QAAd;AACA,SAAOY,OAAP;AACD","sourcesContent":["import { Readable, Writable } from \"stream\"\n\nexport const stringToStream = (s) =>\n  new Readable({\n    read() {\n      this.push(s)\n      // End of data\n      this.push(null)\n    },\n  })\n\nexport const streamToBuffer = (readable) =>\n  new Promise((resolve, reject) => {\n    var chunks = []\n    var writable = new Writable({\n      write(chunk, encoding, callback) {\n        chunks.push(chunk)\n        // Successful write\n        callback()\n      },\n    })\n\n    readable.on(\"end\", () => resolve(Buffer.concat(chunks)))\n    readable.on(\"error\", (error) => reject(error))\n    readable.pipe(writable)\n  })\n\nexport function pipeToPromise(readable, writable) {\n  const promise = new Promise((resolve, reject) => {\n    readable.on(\"error\", (error) => reject(error))\n    writable.on(\"error\", (error) => reject(error))\n    writable.on(\"finish\", (file) => resolve(file))\n  })\n  readable.pipe(writable)\n  return promise\n}\n"],"file":"streamUtil.js"}