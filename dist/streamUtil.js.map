{"version":3,"sources":["../src/streamUtil.js"],"names":["stringToStream","s","Readable","read","push","streamToBuffer","readable","Promise","resolve","reject","chunks","on","chunk","Buffer","concat","streamToString","encoding","then","buffer","toString","pipeToPromise","writable","promise","error","pipe"],"mappings":";;;;;;;;;;AAAA;;AAEO,SAASA,cAAT,CAAwBC,CAAxB,EAA2B;AAChC,SAAO,IAAIC,gBAAJ,CAAa;AAClBC,IAAAA,IAAI,GAAG;AACL,WAAKC,IAAL,CAAUH,CAAV,EADK,CAEL;;AACA,WAAKG,IAAL,CAAU,IAAV;AACD;;AALiB,GAAb,CAAP;AAOD;;AAEM,SAASC,cAAT,CAAwBC,QAAxB,EAAkC;AACvC,SAAO,IAAIC,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AACtC,UAAMC,MAAM,GAAG,EAAf;AAEAJ,IAAAA,QAAQ,CAACK,EAAT,CAAY,MAAZ,EAAqBC,KAAD,IAAWF,MAAM,CAACN,IAAP,CAAYQ,KAAZ,CAA/B;AACAN,IAAAA,QAAQ,CAACK,EAAT,CAAY,OAAZ,EAAqBF,MAArB;AACAH,IAAAA,QAAQ,CAACK,EAAT,CAAY,KAAZ,EAAmB,MAAMH,OAAO,CAACK,MAAM,CAACC,MAAP,CAAcJ,MAAd,CAAD,CAAhC;AACD,GANM,CAAP;AAOD;;AAEM,SAASK,cAAT,CAAwBT,QAAxB,EAAkCU,QAAQ,GAAG,MAA7C,EAAqD;AAC1D,SAAOX,cAAc,CAACC,QAAD,CAAd,CAAyBW,IAAzB,CAA+BC,MAAD,IAAYA,MAAM,CAACC,QAAP,CAAgBH,QAAhB,CAA1C,CAAP;AACD;;AAEM,SAASI,aAAT,CAAuBd,QAAvB,EAAiCe,QAAjC,EAA2C;AAChD,QAAMC,OAAO,GAAG,IAAIf,OAAJ,CAAY,CAACC,OAAD,EAAUC,MAAV,KAAqB;AAC/CH,IAAAA,QAAQ,CAACK,EAAT,CAAY,OAAZ,EAAsBY,KAAD,IAAWd,MAAM,CAACc,KAAD,CAAtC;AACAF,IAAAA,QAAQ,CAACV,EAAT,CAAY,OAAZ,EAAsBY,KAAD,IAAWd,MAAM,CAACc,KAAD,CAAtC;AACAF,IAAAA,QAAQ,CAACV,EAAT,CAAY,QAAZ,EAAsB,MAAMH,OAAO,EAAnC;AACD,GAJe,CAAhB;AAKAF,EAAAA,QAAQ,CAACkB,IAAT,CAAcH,QAAd;AACA,SAAOC,OAAP;AACD","sourcesContent":["import { Readable } from \"stream\"\n\nexport function stringToStream(s) {\n  return new Readable({\n    read() {\n      this.push(s)\n      // End of data\n      this.push(null)\n    },\n  })\n}\n\nexport function streamToBuffer(readable) {\n  return new Promise((resolve, reject) => {\n    const chunks = []\n\n    readable.on(\"data\", (chunk) => chunks.push(chunk))\n    readable.on(\"error\", reject)\n    readable.on(\"end\", () => resolve(Buffer.concat(chunks)))\n  })\n}\n\nexport function streamToString(readable, encoding = \"utf8\") {\n  return streamToBuffer(readable).then((buffer) => buffer.toString(encoding))\n}\n\nexport function pipeToPromise(readable, writable) {\n  const promise = new Promise((resolve, reject) => {\n    readable.on(\"error\", (error) => reject(error))\n    writable.on(\"error\", (error) => reject(error))\n    writable.on(\"finish\", () => resolve())\n  })\n  readable.pipe(writable)\n  return promise\n}\n"],"file":"streamUtil.js"}